---
title: "Part 2: Echo"
---

import PlayIcon from '@material-ui/icons/PlayArrowSharp'
import RestartIcon from '@material-ui/icons/ReplaySharp'
import StopIcon from '@material-ui/icons/StopSharp'

Now that you've successfully run a simple "_Hello World_" server using Pipy.
In this part of tutorial, you'll learn how to let the server respond with
dynamic contents.

# Echo server

First, let's make the server repeat whatever you say on port 8081:

``` js
  pipy()

  .listen(8080)
    .serveHTTP(
      new Message('Hi, there!\n')
    )

+ .listen(8081)
+   .serveHTTP(
+     msg => new Message(msg.body)
+   )
```

As you can see, we are not creating a new program. Instead, we are only extending
the program from last time by adding one more _port pipeline_ to it.

The new pipeline listens on port 8081 and contains the same filter _serveHTTP_ as last time.
But unlike last time, the construction parameter we give to _serveHTTP_ is not a
[_Message_](/reference/classes/Message) object but a **function**.

This **function** is the secret ingredient to our dynamic content.

## Code dissection

In the first pipeline, `new Message()` will be evaluated only once when Pipy starts.
That would leave us with only one _Message_ object no matter how many requests Pipy
could receive later on. Therefore, responses from Pipy will never change.

In the second pipeline, `msg => new Message()` is also evaluated only once when
Pipy starts, but unlike the first one, this evaluation results in a **function**,
not a _Message_ object just yet. At runtime, the function will be evaluated
**once for each request** to get a _Message_ in response, which can be different
every time.

This function has an input variable `msg`, which is the received HTTP request wrapped
in form of a [_Message_](/reference/classes/Message) object. It is supposed to output
a _Message_ too for the response. Here we simply throw together a new _Message_ with
the same body content as the request. That would be enough for our simple "echo server".

## Test in action

Don't forget to save your changes before testing. If Pipy is still running the
old version of the code at this point, you can either:

1. Click <StopIcon/> button to stop the old version, and then click <PlayIcon/>
   button to run the new version.

2. Or click <RestartIcon/> button to restart the program straight in new version.

Again, we'll test it with `curl` from the command line:

``` sh
curl localhost:8081 -d 'hello'
```

Then you should see:

```
hello
```

Awesome!

# Echo more

Certainly we can do more than a "_parrot_". Now let's respond with not only
what the client says, but also where he/she is, shall we?

``` js
  pipy()

  .listen(8080)
    .serveHTTP(
      new Message('Hi, there!\n')
    )

  .listen(8081)
    .serveHTTP(
      msg => new Message(msg.body)
    )

+ .listen(8082)
+   .serveHTTP(
+     msg => new Message(
+       `You are requesting ${msg.head.path} from ${__inbound.remoteAddress}\n`
+     )
+   )
```

Again, we are adding upon what we already have. This time, a new pipeline
listens on port 8082, with the same filter _serveHTTP_ but a different function.

## Code dissection

This time we will return dynamically composed text content by using
[_template string_](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals)
in JavaScript. In that template string, we have 2 dynamic parts:

* `msg.head.path` is the requested URI in the HTTP request
* `__inbound.remoteAddress` is the client's IP address

Variable `__inbound` is a builtin global object containing address/port information about
the current inbound connection. Although it is a _global variable_, it has different
values across concurrent pipelines that handle concurrent inbound connections.

This may be counterintuitive to those who are used to global variables having a shared
state across the whole program. For a deeper explanation, see
[Context](/concepts#context) in _Concepts_.

## Test in action

Now if you say on the terminal:

``` sh
curl localhost:8082/hello
```

You will get:

```
You are requesting /hello from ::1
```

Where "_::1_" is the _localhost_ address in IPv6 form.

# Summary

In this part of tutorial, you've learned how dynamic content can be made
in responses from a Pipy program. You've also tasted a bit of how _variables_
work in Pipy.

## Takeaways

1. Filter parameters are only evaluated once so they have a "_static_" value
   at runtime. To make them "_dynamic_", they need to be **functions** that output
   dynamic values.

2. Global variables have isolated states between concurrent pipelines. One of
   the builtin global variables is `__inbound`, which contains address/port
   information about the current incoming connection.

## What's next?

We've seen that Pipy is good for quickly spinning up an ad-hoc server, but
that's not what Pipy is mainly for. We use Pipy mostly as a network proxy.
That's what we are going to look into next.
